<?xml version="1.0" encoding="utf-8" ?>

<rdf:RDF 
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:admin="http://webns.net/mvcb/"
   xmlns:content="http://purl.org/rss/1.0/modules/content/"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
   xmlns:wfw="http://wellformedweb.org/CommentAPI/"
   xmlns="http://my.netscape.com/rdf/simple/0.9/">
<channel>
    <title>4am</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/</link>
    <description>Si no tiene solución, no es un problema...</description>
    <dc:language>es</dc:language>
    <admin:errorReportsTo rdf:resource="mailto:" />

    <image rdf:resource="http://www.lug.fi.uba.ar/~luca/4am/templates/default/img/s9y_banner_small.png" />

    <items>
      <rdf:Seq>
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/15-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/14-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/13-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/12-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/11-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/10-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/9-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/8-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/7-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/6-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/5-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/4-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/3-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/2-guid.html" />
        <rdf:li resource="http://www.lug.fi.uba.ar/~luca/4am/archives/1-guid.html" />
      </rdf:Seq>
    </items>
</channel>

<image rdf:about="http://www.lug.fi.uba.ar/~luca/4am/templates/default/img/s9y_banner_small.png">
        <url>http://www.lug.fi.uba.ar/~luca/4am/templates/default/img/s9y_banner_small.png</url>
        <title>RSS: 4am - Si no tiene solución, no es un problema...</title>
        <link>http://www.lug.fi.uba.ar/~luca/4am/</link>
        <width>100</width>
        <height>21</height>
    </image>


<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/15-guid.html">
    <title>What To Know Before Debating Type Systems</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/15-What-To-Know-Before-Debating-Type-Systems.html</link>
    <description>
    &lt;p&gt;No es un graaan artículo, pero puede ser interesante, en particular la enumeración de falacias, si no sabés mucho al respecto.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cdsmith.twu.net/types.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;What To Know Before Debating Type Systems&lt;/a&gt;&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Teoría de Lenguaje, </dc:subject>
    <dc:date>2008-05-13T13:46:35Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=15</wfw:comment>
        <slash:comments>1</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=15</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/14-guid.html">
    <title>Soporte de programación funcional en un lenguaje imperativo</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/14-Soporte-de-programacion-funcional-en-un-lenguaje-imperativo.html</link>
    <description>
    &lt;p&gt;&lt;a href=&quot;http://www.digitalmars.com/d/2.0/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;D2.0&lt;/a&gt; tiene como uno de los principales objetivos, agregar soporte de programación funcional, para, por sobre todas las cosas, mejorar el soporte de multiprogramación (principalmente gracias a su capacidad de evitar los &lt;i&gt;side effects&lt;/i&gt;).&lt;/p&gt;

&lt;p&gt;Está habiendo mucha discusión en el &lt;a href=&quot;http://www.digitalmars.com/NewsGroup.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;grupo de noticias de D&lt;/a&gt; y es un tema interesante, en el que, al menos que yo sepa, nadie se había metido antes.&lt;/p&gt;

&lt;p&gt;Empezar a leer todos los &lt;i&gt;threads&lt;/i&gt; al respecto podría ser &lt;i&gt;overkill&lt;/i&gt;, y todavía no hay documentación acerca de los nuevos &lt;i&gt;features&lt;/i&gt; (la &lt;a href=&quot;http://www.digitalmars.com/d/2.0/const.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;página acerca de const&lt;/a&gt; está desactualizada y su &lt;a href=&quot;http://www.digitalmars.com/d/2.0/const-faq.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;FAQ&lt;/a&gt; dice muy poco por ahora), así que si quieren introducirse en el tema, creo que el mejor resumen del objetivo que se persigue con esto es una &lt;a href=&quot;http://www.digitalmars.com/d/2.0/accu-functional.pdf&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;presentación&lt;/a&gt; que hizo recientemente &lt;a href=&quot;http://erdani.org/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Andrei Alexandrescu&lt;/a&gt; (quien está muy involucrado en el diseño de D 2.0).&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    D Programming Language, Teoría de Lenguaje, </dc:subject>
    <dc:date>2008-04-04T23:50:33Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=14</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=14</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/13-guid.html">
    <title>Member function pointer nightmare</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/13-Member-function-pointer-nightmare.html</link>
    <description>
    &lt;p&gt;Me crucé con un (viejo) &lt;a href=&quot;http://www.codeproject.com/cpp/FastDelegate.asp&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;artículo&lt;/a&gt; de Don Clugston bastante interesante acerca de como implementar delegados eficientes en C++.&lt;/p&gt;

&lt;p&gt;El artículo tiene una introducción (bah, &amp;quot;introducción&amp;quot;, es alrededor del 75% del artículo) que explica lo compleja (y dispar) que es la implementación de punteros a funciones miembro; es realmente de ciencia ficción.&lt;/p&gt;

&lt;p&gt;En fin, no me gustaría tener que implementar un compilador de C++.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advertencia:&lt;/strong&gt; Si es cardíaco o impresionable, no lea este artículo. Como para que se den una idea de lo lindo que es esto, les dejo un extracto del código (prestar atención a los nombres):&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;//        horrible_cast&amp;lt; &amp;gt;
// This is truly evil. It completely subverts C++&#039;s type system, allowing you 
// to cast from any class to any other class. Technically, using a union 
// to perform the cast is undefined behaviour (even in C). But we can see if
// it is OK by checking that the union is the same size as each of its members.
// horrible_cast&amp;lt;&amp;gt; should only be used for compiler-specific workarounds. 
// Usage is identical to reinterpret_cast&amp;lt;&amp;gt;.

// This union is declared outside the horrible_cast because BCC 5.5.1
// can&#039;t inline a function with a nested class, and gives a warning.
template &amp;lt;class OutputClass, class InputClass&amp;gt;
union horrible_union{
    OutputClass out;
    InputClass in;
};

template &amp;lt;class OutputClass, class InputClass&amp;gt;
inline OutputClass horrible_cast(const InputClass input){
    horrible_union&amp;lt;OutputClass, InputClass&amp;gt; u;
    // Cause a compile-time error if in, out and u are not the same size.
    // If the compile fails here, it means the compiler has peculiar
    // unions which would prevent the cast from working.
    typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u) 
        &amp;amp;&amp;amp; sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];
    u.in = input;
    return u.out;
}&lt;/code&gt;&lt;/pre&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    C++, Código, Teoría de Lenguaje, </dc:subject>
    <dc:date>2007-03-30T02:00:34Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=13</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=13</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/12-guid.html">
    <title>Worse is better</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/12-Worse-is-better.html</link>
    <description>
    &lt;p&gt;Por casualidad me encontré con un pequeño documento que da una interesante explicación al éxito (o supervivencia?) de Unix y C. El documento se llama &lt;a href=&quot;http://www.jwz.org/doc/worse-is-better.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;The Rise of &amp;quot;Worse is Better&amp;quot;&lt;/a&gt; y dice que Unix y C fueron diseñador con la simplicidad (y en particular de la implementación) por sobre todos los demás aspectos (incluso la &lt;i&gt;correctitud&lt;/i&gt;, &lt;i&gt;completitud&lt;/i&gt; y simplicidad de las interfaces), a diferencia de otros pares, dando como ejemplo a LISP de lenguaje &lt;i&gt;hecho bien&lt;/i&gt; que no prosperó.&lt;/p&gt;

&lt;p&gt;Creo que esto podría ser aplicable a Linux vs. HURD, si bien teóricamente un microkernel pueda ser &lt;strong&gt;mejor&lt;/strong&gt;, un kernel monolítico es más &lt;strong&gt;simple&lt;/strong&gt; y tiene muchas más chances de sobrevivir y de adaptarse a otras plataformas (ser más portable) y por lo tanto expandirse, aún cuando el diseño pueda ser teóricamente &lt;i&gt;peor&lt;/i&gt; que el de HURD (y no sé si realmente sea el caso, pero es de los pocos argumentos que se escuchan a favor de los microkernels).&lt;/p&gt;

&lt;p&gt;En fin, sea como sea me parece interesante la lectura del artículo ;)&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Sistema Operativo, Teoría de Lenguaje, </dc:subject>
    <dc:date>2006-01-24T01:00:09Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=12</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=12</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/11-guid.html">
    <title>9P y v9fs</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/11-9P-y-v9fs.html</link>
    <description>
    &lt;p&gt;9P es un protocolo para compartir recursos distribuidos, desarrollado como parte del gran sistema operativo &lt;a href=&quot;http://www.cs.bell-labs.com/plan9dist/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;plan9&lt;/a&gt;. En particular, uno de sus principales usos es el de compartir archivos, de forma similar a NFS. Para mas informacion, pueden ver el &lt;a href=&quot;http://plan9.bell-labs.com/magic/man2html/5/0intro&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;manpage introductorio&lt;/a&gt; y la &lt;a href=&quot;http://v9fs.sourceforge.net/rfc/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;documentacion de v9fs&lt;/a&gt;.&lt;br /&gt;
9P2000 es la version revisada de 9P, incluida en la cuarta edicion de plan9 (e Inferno), y contiene numerosas mejoras al protocolo original.&lt;/p&gt;

&lt;p&gt;Recientemente, en la version 2.6.14, se incluyó en linux v9fs, que es la implementación de un cliente de 9P2000 (aunque tambien soporta 9P), lo cual nos permite nativamente montar los archivos que sirve un server 9P2000, que bien puede ser plan9, o desde Linux la aplicación u9fs.&lt;br /&gt;
 Es bastante simple y liviano, y posee caracteristicas muy interesantes, algunas de las cuales se mencionan en  &lt;a href=&quot;http://kerneltrap.org/node/5339&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;kerneltrap&lt;/a&gt;, y otras en un paper publicado en USENIX 2005 bajo el titulo de &amp;quot;Grave Robbers from Outer Space - Using 9P2000 Under Linux&amp;quot; por Eric Van Hensbergen y Ron Minnich (aparece si lo buscan en Google y lo ven desde el cache, porque sino es pago). Tambien hay un artículo muy interesante en &lt;a href=&quot;http://lwn.net/Articles/137439/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;LWN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Si bien no es un reemplazo completo de NFS, dado que no tiene varias de las caracteristicas mas avanzadas de POSIX, puede ser muy útil como una alternativa simple y práctica para compartir cosas rápidamente. Ademas al ser tan transparente no tiene mucho problema exportando devices o archivos raros.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Como no abunda documentación al respecto, vamos a ver una pequeña guia de como poner un server y montar un filesystem completamete desde Linux.&lt;/p&gt;

&lt;p&gt;Supongamos que tenemos dos compus, una con la IP 192.168.26.1 (que hara de cliente) y otra con la IP 192.168.26.2 (que hara de server).&lt;/p&gt;

&lt;p&gt;Por empezar, instalaremos u9fs, que es la aplicacion que sirve los archivos, en el server. Para ello lo bajamos de la página de [v9fs.sf.net v9fs] (si tenemos Gentoo podemos usar directamente el &lt;a href=&quot;http://bugs.gentoo.org/show_bug.cgi?id=88665&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;ebuild&lt;/a&gt;, que por ahora esta en el bugzilla), lo compilamos con &lt;em&gt;make&lt;/em&gt; y lo instalamos con &lt;em&gt;make install&lt;/em&gt;, quedando instalado el binario en &lt;em&gt;/usr/sbin/u9fs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Como u9fs no es un server stand-alone sino que usa xinetd (o inetd, o cualquiera de sus amigos), necesitaremos configurarlos a tal efecto. Para el caso de xinetd, pueden encontrar un &lt;a href=&quot;http://bugs.gentoo.org/attachment.cgi?id=71357&amp;amp;action=view&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;ejemplo&lt;/a&gt;, o en el manual incluido en la distribución.&lt;/p&gt;

&lt;p&gt;Una cosa que hay que decidir es como autenticar los usuarios en el server. Hay tres alternativas:&lt;br /&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;em&gt;none&lt;/em&gt;, que no autentica&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;rhosts&lt;/em&gt;, que usa rhosts&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;p9any&lt;/em&gt;, que usa mecanismos de autenticación de plan9.&lt;/li&gt;
&lt;/ul&gt;

&lt;/p&gt;

&lt;p&gt;Vamos a usar rhosts, que es simple.&lt;/p&gt;

&lt;p&gt;Para ello,  agregamos en el rhosts del usuario que queremos permitir montar, la IP del cliente:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;192.168.26.1&amp;quot; &amp;gt;&amp;gt; $HOME/.rhosts
$ chmod 600 $HOME/.rhosts&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y luego iniciamos el servicio de xinetd. Hay que asegurarse que el cliente este en &lt;tt&gt;/etc/hosts&lt;/tt&gt; (debido a como funciona u9fs).&lt;/p&gt;

&lt;p&gt;u9fs toma diversos parametros y un path (opcionalmente, sino lo toma como &amp;quot;/&amp;quot;) que es la raiz de lo que exporta. Si nos  gustaria exportar mas de una cosa, podemos crear un directorio &amp;quot;bobo&amp;quot; y hacer links/bind mounts.&lt;/p&gt;

&lt;p&gt;Ahora que tenemos el server corriendo, vamos a la maquina cliente y montamos lo exportado:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;# mount -t 9P -o name=username 192.168.26.2 /mnt/tmp/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y listo! En &lt;tt&gt;/mnt/tmp&lt;/tt&gt; tendremos lo que se exporto desde el server, y lo estaremos accediendo con el usuario &lt;em&gt;username&lt;/em&gt; del server.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>albertogli@telpin.com.ar (Alberto Bertogli)</dc:creator>
    <dc:subject>
    Filesystems, </dc:subject>
    <dc:date>2006-01-03T03:38:57Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=11</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=11</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/10-guid.html">
    <title>Curso de escritura de papers</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/10-Curso-de-escritura-de-papers.html</link>
    <description>
    &lt;p&gt;A través del diario &lt;a href=&quot;http://www.pagina12web.com.ar/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Página 12&lt;/a&gt; nos enteramos de un &lt;a href=&quot;http://www.pagina12web.com.ar/diario/suplementos/futuro/16-2005-08-27.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;curso-taller de escritura de artículos científicos (papers)&lt;/a&gt; en la &lt;a href=&quot;http://www.fcen.uba.ar/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Facultad de Ciencias Exactas y Naturales &lt;/a&gt; de la &lt;a href=&quot;http://www.uba.ar/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;UBA&lt;/a&gt;.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Charlas, </dc:subject>
    <dc:date>2005-08-30T16:32:04Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=10</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=10</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/9-guid.html">
    <title>VL</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/9-VL.html</link>
    <description>
    &lt;p&gt;Volvemos al &lt;a href=&quot;http://www.lug.fi.uba.ar/~luca/4am/archives/4-La-aventura-de-contar-referencias.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;conteo de referencias&lt;/a&gt;, ahora con el algoritmo que hemos llamado &lt;strong&gt;VL&lt;/strong&gt;. El nombre surge de un flag al cual no sabía que nombre ponerle, y a falta de mejor nombre, al hablar con Alberto, le decía &lt;i&gt;valor_loco&lt;/i&gt; (&lt;i&gt;VL&lt;/i&gt; para ahorrar palabras).&lt;/p&gt;

&lt;p&gt;Bien la idea del algoritmo es detectar &lt;i&gt;ciclos simples&lt;/i&gt; sin referencias externas y liberarlos en una sola pasada, utilizando un flag (&lt;strong&gt;VL&lt;/strong&gt;) que actuaría de algo así como &lt;i&gt;dirty bit&lt;/i&gt;. La idea es comenzar con &lt;tt&gt;VL = 0&lt;/tt&gt; y mantenerlo hasta encontrar, en la recorrida de la primera pasada del &lt;a href=&quot;http://www.lug.fi.uba.ar/~luca/4am/archives/7-L+.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;L+&lt;/a&gt;, algún nodo con &lt;tt&gt;RC &amp;gt; 0&lt;/tt&gt;. Además hay que guardar el nodo del cual partimos (&lt;strong&gt;R&lt;/strong&gt;). Entonces, si en algún momento llegamos al principio, tenemos su contador en cero y el flag es cero (&lt;tt&gt;nodo_actual == R and RC(R) == 0 and VL == 0&lt;/tt&gt;), podemos asegurar que encontramos un ciclo simple, y podemos liberar, al retornar en el stack, todos los nodos por los que pasamos. Esto se ve claramente en la figura 1, donde todos los nodos, después de eliminar la referencia externa a &lt;strong&gt;A&lt;/strong&gt;, tienen un &lt;strong&gt;RC&lt;/strong&gt; de 1, que al ir recorriéndose (en lo que sería la primera pasada del &lt;strong&gt;L+&lt;/strong&gt;) quedarían en 0 y se llegaría a la condición mencionada anteriormente.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.lug.fi.uba.ar/~luca/4am/uploads/diagramas/VL1.png&quot; alt=&quot;Figura 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;En papel la cosa parecía bastante implementable y viable, ya que se a simple vista se agrega muy poco &lt;i&gt;overhead&lt;/i&gt; en cuanto a memoria al menos; incluso parecía funcionar con casos un poco más rebuscados como el de la figura 2. Desgraciadamente, cuando me puse a hacer implementación simple de prueba, la cosa se complicó bastante. Ya el hecho de &lt;i&gt;dividir en 2&lt;/i&gt; la primera pasada del &lt;strong&gt;L+&lt;/strong&gt; complica bastante las cosas y &lt;i&gt;ensucia&lt;/i&gt; mucho el algoritmo original, que es bellísimamente simple =)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.lug.fi.uba.ar/~luca/4am/uploads/diagramas/VL2.png&quot; alt=&quot;Figura 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Además, al haber tantos casos particulares, se agrega más complejidad aún, y al manejar tan pocos casos creo que no vale la pena el &lt;i&gt;overhead&lt;/i&gt; en cuanto a computación y a complejidad que le agrega. Para que se den una idea, las funciones del &lt;strong&gt;L+&lt;/strong&gt; &lt;tt&gt;mark_dec()&lt;/tt&gt;, &lt;tt&gt;unmark_inc()&lt;/tt&gt; y &lt;tt&gt;unmark_del()&lt;/tt&gt; tienen 30 líneas de código; al ser modificadas para el &lt;strong&gt;VL&lt;/strong&gt; ya son 50 (creció un 67%) y todavía no termino de llenar todos los &lt;i&gt;huecos&lt;/i&gt; que deja. Evidentemente no tiene mucho sentido terminarlo, así que quedará sólo en una (buena?) idea.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Reference Counting, </dc:subject>
    <dc:date>2005-08-09T02:37:17Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=9</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=9</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/8-guid.html">
    <title>Ada tasks para Python</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/8-Ada-tasks-para-Python.html</link>
    <description>
    &lt;p&gt;Ada es un lenguaje de programación que probablemente hayan escuchado nombrar, nacido originalmente para la gente tan decente del Departamento de Defensa de los Estados Unidos; no es demasiado popular pero tiene una base de usuarios respetable y esta estandarizado por la ISO. No voy a hablar mucho mas de él, si les interesa pueden ver &lt;a href=&quot;http://www.adahome.com&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Ada Home&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como lenguaje no tiene mucha gracia (y encima tiene una sintaxis parecida a la de Pascal),  pero la forma de manejar concurrencia es linda y bastante cómoda para muchos usos. Como me gustó (lo vimos en Teoría de Lenguaje con Rosita, en una de las presentaciones), decidí implementar algo similar para Python, que no es exactamente lo mismo pero se le asemeja bastante.&lt;br /&gt;
 La idea básica es definir &lt;em&gt;tasks&lt;/em&gt;, que son en principio funciones que se ejecutan  asincrónicamente (en un thread aparte). En Ada se definen de forma natural, pero son prácticamente iguales a las funciones. En esta implementación puede haber varias instancias de una misma tarea.&lt;/p&gt;

&lt;p&gt;A su vez, cada task tiene un canal asociado por el cual podemos enviarle cierta información, la cual tiene la forma &lt;em&gt;(entry, parametros)&lt;/em&gt;; en donde el entry es un nombre descriptivo, y los parámetros son el conjunto de valores que lo acompañan, en una tupla.&lt;/p&gt;

&lt;p&gt;Entonces, cada task puede recibir uno o mas entries; y existen dos mecanismos para poder esperar a que llegue un entry: estos son &lt;tt&gt;accept()&lt;/tt&gt; y &lt;tt&gt;select()&lt;/tt&gt;. El primero espera hasta que le manden un entry dado y devuelve el valor que se asocio; y el segundo es similar pero espera por alguno de los entries dados (o por cualquiera) y devuelve el par &lt;tt&gt;(entry, parametros)&lt;/tt&gt;. Los parámetros se devuelven siempre como una tupla dado que su longitud es variable.&lt;/p&gt;

&lt;p&gt;Los entries se encolan, y son por tarea y no por instancia, lo que nos permite lanzar múltiples instancias de una misma tarea y al enviar un entry solo lo recibirá una sola instancia.&lt;/p&gt;

&lt;p&gt;Como se ve, esta construcción es muy simple, pero para muchos de los casos prácticos de uso de concurrencia resulta muy cómoda; por ejemplo para el manejo de eventos con callbacks asincrónicos, modelos de productor/consumidor, etc.&lt;/p&gt;

&lt;p&gt;Veamos un ejemplo:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;import adatasks

@adatasks.task
def f():
        print &#039;&amp;gt; ejecutando task&#039;
        v = f.accept(&#039;comando&#039;)[0]
        while v != &#039;salir&#039;:
                print &#039;&amp;gt; entry:&#039;, v
                v = f.accept(&#039;comando&#039;)[0]
        print &#039;&amp;gt; chau&#039;

def main():
        print &#039;arrancamos&#039;

        # iniciamos todas las tareas
        adatasks.launch()

        # le mandamos comandos
        f.comando(&#039;salames&#039;)
        f.comando(&#039;jamon&#039;)
        f.comando(&#039;salir&#039;)

        print &#039;esperamos&#039;
        adatasks.wait_for_all()

        print &#039;terminamos&#039;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Al principio definimos la tarea con el decorator, la cual es una función sin parámetros que acepta un entry e imprime su único valor, a menos que este sea &lt;em&gt;salir&lt;/em&gt; en cuyo caso termina.&lt;/p&gt;

&lt;p&gt;Luego definimos la función principal, que inicia la ejecución de las tareas (en nuestro caso hay una sola), le envía tres entries &lt;em&gt;comando&lt;/em&gt; con tres parámetros distintos, y espera a que concluyan todas las tareas. De no realizarse este ultimo paso, el programa terminaría sin esperar a que concluyan todas las tareas.&lt;/p&gt;

&lt;p&gt;Entonces, la salida es:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;arrancamos
esperamos
&amp;gt; ejecutando task
&amp;gt; entry: salames
&amp;gt; entry: jamon
&amp;gt; chau
terminamos&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La implementación es bastante fácil: usamos un decorator para la función y este la convierte en una clase que la envuelve, creando una cola especial para manejar los entries y proveyendo las funciones apropiadas que hacen falta para encolarlos y esperar por ellos.&lt;/p&gt;

&lt;p&gt;Para los entries, se usa internamente un diccionario que vive a nivel del módulo, el cual se indexa con el nombre del task y contiene una cola especial para almacenar los entries pendientes. Toda la notificación se realiza usando condition mutexes (que, dicho sea de paso, si bien están implementados de una forma similar a los de pthreads, son mucho mas amistosos de usar (debido a Python mas que nada)).&lt;/p&gt;

&lt;p&gt;Además, para esperar la finalización de tareas tenemos otro diccionario que almacena un contador de instancias, y notificamos a los que esperan cuando este llega a 0.&lt;/p&gt;

&lt;p&gt;Como cosas pendientes que se podrían hacer en un futuro es implementar timeouts opcionales, y algún mecanismo para poder compartir colas de entries entre distintas tareas, aunque no se si vale la pena la complicación. Otra cosa útil y mas divertida puede ser extender este modelo para correr los tasks en otras maquinas, distribuyendo la aplicación y convirtiendo los entries en pasos de mensaje; no es nada complicado de implementar, aunque ciertamente seria una solución mas específica.&lt;/p&gt;

&lt;p&gt;Hay bastantes mas cosas que se pueden hacer con esto, pero creo que esto esta quedando demasiado largo (todavía no entiendo muy bien que onda esto de los blogs) así que mejor dejo acá.&lt;/p&gt;

&lt;p&gt;Si quieren ver, hay &lt;a href=&quot;http://users.auriga.wearlab.de/~alb/repos/pymisc/samples/adatasks/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;mas ejemplos&lt;/a&gt;, y también esta &lt;a href=&quot;http://users.auriga.wearlab.de/~alb/repos/pymisc/adatasks.py&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;el código fuente&lt;/a&gt; si lo quieren usar (esta en un &lt;a href=&quot;http://users.auriga.wearlab.de/~alb/repos/pymisc/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;repositorio darcs&lt;/a&gt;, así que también pueden obtenerlo por ese medio).&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>albertogli@telpin.com.ar (Alberto Bertogli)</dc:creator>
    <dc:subject>
    Concurrencia, Código, Python, </dc:subject>
    <dc:date>2005-08-07T02:09:56Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=8</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=8</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/7-guid.html">
    <title>L+</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/7-L+.html</link>
    <description>
    &lt;p&gt;L+ es un algorito de detección y liberación de ciclos al hacer conteo de referencias que, al fin y al cabo, es una optimización al algoritmo de Lins (en parte el nombre &lt;strong&gt;L+&lt;/strong&gt; significa &lt;strong&gt;Lins+&lt;/strong&gt;). Para quienes conozcan este último, lo que se propone &lt;strong&gt;L+&lt;/strong&gt; es agregar una lista (otra de las razones para el nombre proviene de llamar a esa lista &lt;strong&gt;L&lt;/strong&gt;, aunque a la hora de implementarlo tenga más sentido usar un &lt;i&gt;set&lt;/i&gt;) de los nodos que quedan con una cantidad de referencias mayor a cero luego del &lt;tt&gt;mark_grey()&lt;/tt&gt;, de manera tal de evitarse la pasada del &lt;tt&gt;scan()&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;En vez de realizar el &lt;tt&gt;scan()&lt;/tt&gt; para encontrar nodos con referencias externas, se obtienen de la lista &lt;strong&gt;L&lt;/strong&gt;. De forma análoga al &lt;tt&gt;scan()&lt;/tt&gt;, a cada elemento de la lista se le corre el &lt;tt&gt;mark_black()&lt;/tt&gt; para  reestablecer los contadores.&lt;/p&gt;

&lt;p&gt;Finalmente sólo queda borrar recursivamente todos los nodos partiendo del nodo original que &lt;i&gt;disparó&lt;/i&gt; la detección de ciclos, &lt;i&gt;cortando&lt;/i&gt; la recursividad cuando se encuentra un nodo con un contador mayor a cero. Para aquellos que no conozcan el algoritmo de Lins, voy a explicar el &lt;strong&gt;L+&lt;/strong&gt; completo. Y para aquellos que lo conozcan la explicación también puede servir porque se simplifica bastante.&lt;/p&gt;

&lt;p&gt;Vale la pena aclarar que no se habla aquí de &lt;i&gt;lazyness&lt;/i&gt;, ya que esta característica es ortogonal al algoritmo en sí. Tanto el algoritmo de Lins como este pueden ser &lt;i&gt;lazy&lt;/i&gt; agregando el bit de &lt;i&gt;dirty&lt;/i&gt; (o poniendo el color púrpura según el libro) y poniendo las referencias compartidas, al eliminarlas, en un &lt;i&gt;control set&lt;/i&gt; para buscar los ciclos más tarde. Con esto aclarado, veamos el algoritmo.&lt;/p&gt;

&lt;p&gt;Todo parte de la base de 3 primitivas para el manejo del conteo de referencias (en el pseudocódigo usado en el libro):&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;new() =
    newcell = allocate() # funci&amp;oacute;n que aloca memoria
    # Suponemos memoria infinita, de no ser as&amp;iacute; habr&amp;iacute;a que
    # verificar que se haya alocado correctamente.
    RC(newcell) = 1
    # RC(newcell) devuelve un lvalue al contador de newcell
    MARK(newcell) = 0
    # MARK(newcell) devuelve un lvalue a la marca de newcell
    return newcell

delete(T) =
    if RC(T) == 1
        for U in Children(T) # Por cada puntero de T
            delete(*U)
        free(T) # funci&amp;oacute;n que libera memoria
    else
        mark_dec(T)
        for U in L
            unmark_inc(U)
        clear(L) # vac&amp;iacute;a la lista
        unmark_del(T)

update(R, S):
    RC(S) = RC(S) + 1
    delete(*R)
    *R = S&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En &lt;strong&gt;L+&lt;/strong&gt; se agregan 3 nuevas funciones: &lt;tt&gt;mark_dec()&lt;/tt&gt;, &lt;tt&gt;unmark_inc()&lt;/tt&gt; y &lt;tt&gt;unmark_del()&lt;/tt&gt; que son las encargadas de detectar y liberar ciclos (el algoritmo más básico de conteo de referencias, que pierde memoria si hay ciclos) no tiene el bloque &lt;tt&gt;else&lt;/tt&gt; de la función &lt;tt&gt;delete()&lt;/tt&gt;). Además agrega, como ya dije, la lista &lt;tt&gt;L&lt;/tt&gt; (que es global para simplificar las cosas).&lt;/p&gt;

&lt;p&gt;Veamos ahora las funciones faltantes:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;mark_dec(T) =
    RC(T) = RC(T) - 1
    if RC(T) == 0
        discard(L, T) # saca a T de L
    else
        add(L, T) # agrega T a L (sin duplicar elementos)
    if MARK(T) == 0
        MARK(T) = 1
        for U in Children(T)
            mark_dec(*U)

unmark_inc(T) =
    RC(T) = RC(T) + 1
    if MARK(T) == 1
        MARK(T) = 0
        for U in Children(T)
            unmark_inc(*U)

unmark_del(T) =
    if MARK(T) == 1
        MARK(T) = 0
        for U in Children(T)
            unmark_del(*U)
        free(T)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Al igual que &lt;tt&gt;RC(T)&lt;/tt&gt;, &lt;tt&gt;MARK(T)&lt;/tt&gt; devuelve un &lt;i&gt;lvalue&lt;/i&gt; de la marca para la referencia T. Las 2 pasadas sería en &lt;strong&gt;mark&lt;/strong&gt; por un lado (que marca los nodos decrementado su &lt;strong&gt;RC&lt;/strong&gt; debido a las referencias internas del subgrafo) y el &lt;strong&gt;unmark&lt;/strong&gt; por el otro (dividido en 2, el que por cada nodo con referencias externas reestablece los &lt;strong&gt;RC&lt;/strong&gt; incrementándolos, y el que libera los nodos que quedaron con &lt;tt&gt;RC == 0&lt;/tt&gt;  que coincide con lo que tienen &lt;tt&gt;MARK == 1&lt;/tt&gt;).&lt;/p&gt;

&lt;p&gt;A continuación se presenta una pequeña animación de un caso bastante complicado:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.lug.fi.uba.ar/~luca/4am/uploads/diagramas/L.gif&quot; alt=&quot;L+ en acción&quot; /&gt;&lt;/p&gt;

&lt;p&gt;También dejo una &lt;a href=&quot;http://www.lug.fi.uba.ar/~luca/4am/uploads/fuentes/python/Lx.python&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;implementación de ejemplo en Python&lt;/a&gt;. (la extensión .python es para evitar problemas con el servidor, renombren a .py antes de probarlo). Aunque el grafo que se analiza en el ejemplo es el mismo que el de la animación anterior, la ejecución no es exactamente igual, debido al orden en que se agregan las referencias y se itera sobre el &lt;i&gt;set&lt;/i&gt; &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Código, Python, Reference Counting, </dc:subject>
    <dc:date>2005-08-06T07:12:00Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=7</wfw:comment>
        <slash:comments>-2</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=7</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/6-guid.html">
    <title>C++0x</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/6-C++0x.html</link>
    <description>
    &lt;p&gt;C++0x es el nombre provisorio que le da &lt;a href=&quot;http://www.research.att.com/~bs/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Bjarne Stroustrup&lt;/a&gt; (y no sé si el comité de la ISO entero también) a la nueva revisión del estándar de C++ (que supuestamente estaría saliendo en un par de años). En un breve &lt;a href=&quot;http://www.research.att.com/~bs/rules.pdf&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;paper&lt;/a&gt; explica qué son las cosas que más probablemente cambien o se agreguen. Lo más copado de la nueva revisión es, para mí, que van a tratar de bajarle un poco el &lt;i&gt;overhead sintáctico&lt;/i&gt;. Para esto se agregaría un nuevo uso para la palabra clave &lt;tt&gt;auto&lt;/tt&gt; permitiendo su uso como declaración de tipo, para que lo &lt;i&gt;infiera&lt;/i&gt; de la asignación. Por ejemplo (sacado del paper), algo como:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt;::iterator p =
    find(tbl.begin(), tbl.end(), x);
    // tbl is a const vector&amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;podría escribirse así:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;auto p = find(tbl, x);
    // tbl is a const vector&amp;lt;int&amp;gt;
    // p becomes a vector&amp;lt;int&amp;gt;::const_iterator&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin dudas es mucho más legible y sintético lo segundo. Otro ejemplo es la inicialización de contenedores de la STL. Con algo de suerte agregarían las herramientas necesarias para poder pasar de esto:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;vector&amp;lt;double&amp;gt; v;
v.push_back(1.2);
v.push_back(2.3);
v.push_back(3.4);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a esto:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;vector&amp;lt;double&amp;gt; v = { 1.2, 2.3, 3.4 };&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hay otros cambios mínimos, pero no por eso menos interesantes, que pueden leer directamente en el paper (que son sólo 5 páginas), aunque por supuesto, nada es definitivo aún.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; También se incluirían varias &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/library_technical_report.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;nuevas bibliotecas&lt;/a&gt; a la STL.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    C++, Código, </dc:subject>
    <dc:date>2005-08-03T05:26:46Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=6</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=6</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/5-guid.html">
    <title>SH</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/5-SH.html</link>
    <description>
    &lt;p&gt;El nombre SH viene de Stack-Heap, porque la idea de este algoritmo es diferenciar las referencias que vienen directamente del stack (directas) de las que vienen del heap (o sea, de otros objetos, serían referencias indirectas) de manera tal de poder retrasar la búsqueda de ciclos lo más posible. Básicamente lo que se hace es tener 2 contadores:&lt;/p&gt;

&lt;dl&gt;
&lt;/dl&gt;

&lt;p&gt;Entonces lo que podemos hacer básicamente es lo siguiente. Si al eliminar una referencia el &lt;strong&gt;SC&lt;/strong&gt; sigue siendo mayor a 0, no tengo que chequear si hay ciclos, porque tengo garantizado que de haber un ciclo, éste va a &lt;i&gt;sobrevivir&lt;/i&gt; de todos modos.&lt;/p&gt;

&lt;p&gt;Veamos un ejemplo simple en un diagrama:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.lug.fi.uba.ar/~luca/4am/uploads/diagramas/sh.png&quot; alt=&quot;Ejemplo de funcionamiento de SH&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Si eliminamos la referencia a &lt;strong&gt;A&lt;/strong&gt; que tiene una cruz roja, vemos como el ciclo sigue teniendo una referencia externa y por lo tanto no va a tener que ser eliminado. Una desventaja evidente es la necesidad de un contador extra.&lt;/p&gt;

&lt;p&gt;Este algoritmo no tiene mucha utilidad en realidad, fue pensado sólo para implementar &lt;a href=&quot;http://www.boost.org/libs/smart_ptr/smart_ptr.htm&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;smart pointers&lt;/a&gt; con detección de ciclos &lt;strong&gt;no &lt;i&gt;lazy&lt;/i&gt;&lt;/strong&gt; en C++. Al no tener soporte en el compilador y al ser no &lt;i&gt;lazy&lt;/i&gt;, de no hacerse esto, se van a verificar ciclos prácticamente cada vez que se pase una referencia (&lt;i&gt;smart pointer&lt;/i&gt;) por parámetro (que haya sido almacenada en el stack), ya que al retornar de la función se destruye el &lt;i&gt;smart pointer&lt;/i&gt; y éste iniciaría una búsqueda de ciclos. Veamos un ejemplo con código para aclarar:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;void foo()
{
    smart_ptr&amp;lt;Objeto&amp;gt; ref = new Objeto;
    bar(ref);
}
void bar(smart_ptr&amp;lt;Objeto&amp;gt; ref)
{
    return;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso, usando un conteo de referencias normal, luego del &lt;tt&gt;return&lt;/tt&gt; de &lt;tt&gt;bar()&lt;/tt&gt; se destruye el &lt;tt&gt;smart_ptr&lt;/tt&gt; y debe iniciarse una búsqueda de ciclos. Si usamos el &lt;strong&gt;SC&lt;/strong&gt;, al entrar en &lt;tt&gt;bar()&lt;/tt&gt; (al copiarse el &lt;tt&gt;smart_ptr&lt;/tt&gt;), el &lt;strong&gt;SC&lt;/strong&gt; del &lt;tt&gt;Objeto&lt;/tt&gt; será 2 y después del &lt;tt&gt;return&lt;/tt&gt;, al destruirse, volverá a ser 1 (y como no es 0, no se necesitará buscar ciclos).&lt;/p&gt;

&lt;p&gt;De disponer soporte en el compilador, probablemente este tipo de optimizaciones puedan hacerse todas con análisis estático (haciendo &lt;i&gt;Deferred reference counting&lt;/i&gt;) y este algoritmo sea completamente inútil y caro.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    C++, Código, Reference Counting, </dc:subject>
    <dc:date>2005-08-02T06:46:00Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=5</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=5</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/4-guid.html">
    <title>La aventura de contar referencias</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/4-La-aventura-de-contar-referencias.html</link>
    <description>
    &lt;p&gt;Todo empezó hace mucho, mucho tiempo (finales de 2004) en una de las famosas reuniones del &lt;a href=&quot;http://www.lug.fi.uba.ar/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;LUGFI&lt;/a&gt; en la L11. Con la excusa de la confección de un &lt;a href=&quot;http://www.fi.uba.ar/materias/7542/enunciados/20051/ej4.pdf&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;ejercicio&lt;/a&gt; sobre &lt;a href=&quot;http://www.boost.org/libs/smart_ptr/smart_ptr.htm&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;smart pointers&lt;/a&gt; para &lt;a href=&quot;http://www.fi.uba.ar/materias/7542/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;taller&lt;/a&gt; empecé a hablar con Alberto sobre el tema (en particular sobre la detección y liberación de ciclos). Esto duró apenas unos días, hasta hace cosa de un par de semanas, cuando se avivó la llama =) Sin dudas tuvo que ver la cursada de &lt;i&gt;Teoría de Lenguaje&lt;/i&gt;, una materia relativamente nueva y por demás interesante, en donde vimos un resumen sobre las técnicas principales de recolección de basura y nos llevamos un &lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/rej/gcbook/gcbook.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;muy buen libro&lt;/a&gt; de &lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/rej/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Richards Jones&lt;/a&gt; y Rafael Lins. Pero sin dudas la gota que rebalsó el vaso fue la charla que dio este último en la facultad.&lt;/p&gt;

&lt;p&gt;En fin, después de bastante trabajo y de ser consumidos por el tema, hemos sacados un par de cosas en limpio, que voy a presentar brevemente y cronológicamente, según las fuimos &lt;i&gt;descubriendo&lt;/i&gt;:&lt;/p&gt;

&lt;dl&gt;
&lt;/dl&gt;

&lt;p&gt;Este es un pantallado general a modo de resumen. En los próximos &lt;i&gt;posts&lt;/i&gt; iremos describiendo detalladamente cada algoritmo, en lo posible incluyendo una implementación de referencia simple.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Reference Counting, </dc:subject>
    <dc:date>2005-08-01T07:24:16Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=4</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=4</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/3-guid.html">
    <title>Mudanza de sistema de blog</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/3-Mudanza-de-sistema-de-blog.html</link>
    <description>
    &lt;p&gt;Sí, apenas tenemos un &lt;i&gt;post&lt;/i&gt; con contenido útil y ya nos mudamos de &lt;i&gt;blog&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;El tema es que el sistema de blog viejo era bastante feote y limitado y eso desalienta bastante a la hora de postear (ok! ok! no teníamos nada interesante para decir, y qué!? =D).&lt;/p&gt;

&lt;p&gt;Ahora estamos usando &lt;a href=&quot;http://www.s9y.org/&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;Serendipity&lt;/a&gt; (AKA s9y) y la verdad que es &lt;strong&gt;muy recomendable&lt;/strong&gt;. Tiene todo lo que necesitamos y muchísimo más también.&lt;/p&gt;

&lt;p&gt;En fin, esperamos estar posteando cosas útiles a la brevedad...&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Institucional, </dc:subject>
    <dc:date>2005-07-31T16:30:31Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=3</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=3</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/2-guid.html">
    <title>Design by contract en Python</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/2-Design-by-contract-en-Python.html</link>
    <description>
    &lt;p&gt;Bueno, aca va el primer post no institucional.&lt;/p&gt;

&lt;p&gt;Yo me quería ir a dormir temprano, pero no, resulta que cuando me estaba yendo cayo Luca con una pregunta de los decorators de Python porque estaba haciendo algunos para soportar design by contract (eso de pre y post condiciones que se habla tanto de Eiffel pero que nadie usa), idea que, a todo esto, a mi mucho no me atrae. Lo que él quería hacer era poner las pre y post condiciones adentro de la función, algo así como:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;@contract
def f(x):
    def pre(x):
        assert x &amp;gt; 0
    def post(ret, x):
        assert ret &amp;gt; x

    return (x + 1) / x&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El tema es que las funciones &lt;tt&gt;pre()&lt;/tt&gt; y &lt;tt&gt;post()&lt;/tt&gt; se definen cuando se comienza a ejecutar &lt;tt&gt;f()&lt;/tt&gt;, por lo que no son accesibles desde afuera y por ende el decorator normal no sirve. Ponerlas afuera es trivial, y hay un ejemplo dando vueltas en el &lt;a href=&quot;http://www.artima.com/weblogs/viewpost.jsp?thread=86641&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;blog de Guido van Rossum&lt;/a&gt; (y también hay &lt;a href=&quot;http://www.python.org/peps/pep-0316.html&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;un PEP&lt;/a&gt; que propone embeber las pre y post condiciones en los docstrings, &lt;strong&gt;horriiiiible&lt;/strong&gt;!).&lt;/p&gt;

&lt;p&gt;Después de un rato de hacer pruebas y ver como se le podía encontrar la vuelta para lograr una sintaxis digerible y útil, quedo así:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;@contract
def f(x):
        @precond(f)
        def pre(x):
                assert x &amp;gt; 0

        @postcond(f)
        def post(ret, x):
                assert ret &amp;gt; 0

        return (x + 1) / x&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lo cual tiene algunas ventajas, en especial permite independizar el nombre de la pre y post condición, y no definir cualquiera de las dos, además de poder ubicarlas en cualquier orden (aunque la precondición correrá en el momento en el que se la defina).&lt;/p&gt;

&lt;p&gt;El decorator &lt;tt&gt;contract()&lt;/tt&gt; define una clase &lt;i&gt;wrapper&lt;/i&gt; que envolverá a la función en cuestión, con dos métodos especiales: uno para ejecutar la precondición y otro para registrar la postcondición, que se ejecutara cuando se termine de correr el código principal.&lt;br /&gt;
Entonces, el decorator precond solo ejecuta la función que decora, y postcond registra la función decorada en la clase &lt;i&gt;wrapper&lt;/i&gt; (por esto es que toma como parametro a &lt;tt&gt;f&lt;/tt&gt; (siguiendo el ejemplo).&lt;/p&gt;

&lt;p&gt;El método &lt;tt&gt;__call__()&lt;/tt&gt; de la clase &lt;i&gt;wrapper&lt;/i&gt; llama al cuerpo de &lt;tt&gt;f()&lt;/tt&gt; y luego, antes de devolver, ejecuta la postcondición registrada (de haberla).&lt;/p&gt;

&lt;p&gt;El código esta en un &lt;a href=&quot;http://users.auriga.wearlab.de/~alb/repos/pymisc&quot; onclick=&quot;window.open(this.href, &#039;_blank&#039;); return false;&quot;&gt;repositorio darcs&lt;/a&gt;, aunque consiste de un solo archivito muy simple, por lo que pueden chusmearlo y bajarlo directamente con el navegador.&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>albertogli@telpin.com.ar (Alberto Bertogli)</dc:creator>
    <dc:subject>
    C++, Design By Contract, Python, </dc:subject>
    <dc:date>2005-07-10T06:49:00Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=2</wfw:comment>
        <slash:comments>-3</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=2</wfw:commentRss>
    
    
</item>
<item rdf:about="http://www.lug.fi.uba.ar/~luca/4am/archives/1-guid.html">
    <title>Génesis</title>
    <link>http://www.lug.fi.uba.ar/~luca/4am/archives/1-Genesis.html</link>
    <description>
    &lt;p&gt;Después de dar algunas vueltas, y buscar un blog simple pero lo suficientemente poderoso como para sentirnos cómodos, ha nacido 4am, un blog concebido en una charla de IRC del canal del LUGFI, luego de un par de días de encontrarnos hablando a las 4am con Alberto de temas de programación algo rebuscados (potenciados por la cursada de Teoría de Lenguaje). Al tener un par de cosillas interesantes para mostrar, pero no tener donde mostrarlo, surgió la idea de este blog, y eso es lo que esperamos que sea, un repositorio de experimentos y rarezas que no sean lo suficientemente grandes como para tener una página o proyecto propio pero que sean lo suficientemente interesantes como para ser mostradas.&lt;/p&gt;

&lt;p&gt;La idea es que sea un blog colectivo (o colaborativo como le gusta decir a algunos), así que cualquiera que tenga algo interesante para mostrar, siéntase libre de pedir un usuario =)&lt;/p&gt;

&lt;p&gt;Qué le depara el futuro este blog? Sólo Dios sabe (si existiera tal cosa ;). En principio creo que no tenemos un objetivo mucho más claro que este, veremos como evoluciona la cosa...&lt;/p&gt;

&lt;p&gt;Bienvenidos, y esperamos que disfruten la función! =)&lt;/p&gt;

 
    </description>

    <dc:publisher>4am</dc:publisher>
    <dc:creator>llucax@gmail.com (Leandro Lucarella)</dc:creator>
    <dc:subject>
    Institucional, </dc:subject>
    <dc:date>2005-07-10T06:08:00Z</dc:date>
    <wfw:comment>http://www.lug.fi.uba.ar/~luca/4am/wfwcomment.php?cid=1</wfw:comment>
        <slash:comments>0</slash:comments>
        <wfw:commentRss>http://www.lug.fi.uba.ar/~luca/4am/rss.php?version=1.0&amp;type=comments&amp;cid=1</wfw:commentRss>
    
    
</item>

</rdf:RDF>
